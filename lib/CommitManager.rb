class CommitManager
  
  
  def initialize(device, xmpp_notifications = true, use_thread = true)
    
    @device = device
    
    @notify = xmpp_notifications
    @useThread = use_thread
    
  end
  

  
  
  #
  #  filelist is a hash table: full filepath as the key and in a hash table are the initial metadatas
  #  commit_hash is generated by Git
  #
  def updateFilelist(filelist, commit_hash, prev_commit_hash = nil, commit_location = nil)
    
    
    begin
      
      if @device == nil
        raise Exception.new("ERROR: Device can't be identified")
      end
      
      commit = nil
      #puts "contains: " + filelist.to_s
      #puts "commit_hash" + commit_hash
      
      # check for correct commit-hashes
      if not commit_hash.to_s.strip =~ /^\w{40}$/        
        raise Exception.new("ERROR: Unidentified Commit-hash")
      else
        commit = @device.commits.find_by_commit_hash(commit_hash)
        if commit != nil
          # if commit has blobs, don't parse given filelist
          if commit.blobs.size > 0
            if @notify 
              puts "Commit already exists, sending parse successful.."
              XmppHelper::sendXmppMessage(@device.xmppname, "parse successful " + commit.commit_hash)
            else
              #puts "Commit already exists!" 
            end
            # check if thumbnails are missing
            if @notify then checkForThumbs(commit) end
            if @notify
              raise Exception.new("Commit already in database") 
            else
              return false
            end
          else
            puts "Commit exists but dosent't have blobs"    
          end
        end
      end

      if prev_commit_hash =~ /^\w{40}$/ and @device.commit_id != nil
        @prev_commit = Commit.find_by_id(@device.commit_id)
        if @prev_commit != nil and @prev_commit.commit_hash != prev_commit_hash
          raise Exception.new("ERROR: Commit not accepted")
        end
      else
        if not (prev_commit_hash == nil and @device.commit_id == nil)
          raise Exception.new("ERROR: Unidentified prev_commit_hash: #{prev_commit_hash}")
        end
      end

      if commit == nil
        puts "creates new commit"
        commit = @device.commits.find_or_create_by_previous_commit_id_and_commit_hash(:previous_commit_id => @device.commit_id,
                                        :commit_hash => commit_hash)
        puts "updates newly created commit to device"
        # Updates created to commit to device
        @device.update_attribute(:commit_id, commit.id)
      else
        puts "not updating the commit id.. Already exists."
      end
      @device.update_attribute(:last_seen, DateTime.now)
      
    rescue Exception => ex
      putsE(ex)
      return false
    end
    
    
    if @useThread
    
      # Thread that goes through filelist and parses it, when finished sends xmpp message to inform client.
      Thread.new do
        
        if parseFiles(commit, filelist, commit_location)
          if @notify then XmppHelper::sendXmppMessage(@device.xmppname, "parse successful " + commit.commit_hash) end
          if @notify then XmppHelper::sendXmppMessage(@device.xmppname, "thumbs " + commit.commit_hash) end          
        else
          if @notify then XmppHelper::sendXmppMessage(@device.xmppname, "parse error " + commit.commit_hash + " Error: " + e.to_s) end
        end
      end
      
      # Response code that tells that parsing is started.
      puts "Filelist parsing started.."
      return true    
    else
      if parseFiles(commit, filelist, commit_location) 
        return true
      else
        return false
      end
    end
  end

  
  
  
  
  
  
  
  ################################################################################################
  #
  #    PRIVATE
  #
  ################################################################################################
  
  
  
  private
  
  
  
  def parseFiles(commit, filelist, commit_location = nil)
    
    begin
        @changed_files = filelist
        # Checks that which files are completely new and which ones already exists (has devfile)
        @changed_files.each do |key, df|
          old_df = Devfile.find_by_name_and_path_and_device_id(df['name'], df['path'], @device.id)
          # If the dev_file already exists
          if old_df
            puts "Already exists: #{key}"
            df.merge!({:dev_file_id => old_df.id.to_s})
            @changed_files[key] = df
            puts "Ensure: " + @changed_files[key].to_s
          else
            puts "Completely new: #{key}"
          end
        end
        
         
        
        
        if commit_location
          lat = commit_location['latitude'].to_f
          lon = commit_location['longitude'].to_f
          if lat == nil or lon == nil
            @commit_location = {'latitude' => 0, 'longitude' => 0}
          end
        else
          @commit_location = {'latitude' => 0, 'longitude' => 0}
        end
        
        @notify_these_observers = {}
        
        commit_devfiles = []
        
        @changed_files.each do |key, f|
          
          devfile = nil
          
          if f[:dev_file_id] or f['status'] == "updated"
            
            devfile = updateDevfile(f, commit)
            
          elsif f['status'] == "created"
            
            devfile = createDevfile(f, commit)
            
          elsif f['status'] == "deleted"
            
         #   deleteDevfile(f, commit)
            
          else
            puts "Unknown status. Status can be: deleted, updated or created"
          end
          
          
          #
          #  Notifications for nodes:
          #
          if devfile
            # Checks if devfile had any observers, and nofies them about updates
            checkForObservers(devfile, @device.user.username, @device.dev_name)
            
            # Checks if devfile matches to any context, and notifies matching contexts
            # => This includes cases were devfile has been added to a context as well as cases where
            # => parameters of a context matches to parameters of the devfile
            commit_devfiles << devfile
            
          end
          
          
        end
        
        Thread.new do
          ContextController::notifyObservers(commit_devfiles)
        end
        
        
        # add all unchanged files from previous commit to this new one
        if @prev_commit != nil
          puts "Adding previous files to the current commit.."
          addUnchangedFilesToCommit(@prev_commit, commit, @changed_files)
        end

      rescue => e
        linenumb = e.backtrace[0].to_s
        
        puts "-- PARSE ERROR on device: " + @device.dev_name + " (" + @device.id.to_s + ")" + " line: #{linenumb}"
        puts "  --  line: #{linenumb}"
        
        
        
        # tämä täytyy tehdä uusiksi! Eli homma täytyy tehdä niin että kokonaan uuden tiedoston ja uuden version lisääminen
        # tapahtuu samalla tavoin. Ennen kuin koko hommaa edes aloitetaan tutkitaan, että ollaanko luomassa kokonaan uutta
        # device.devfiles.find_by_name_and_path.. Jos tulos on nil tiedetään että luodaan uutta, muuten päivitetään vanhaa..
        #
        # Rollbackissa voidaan helposti poistaa myös devfile, mikäli oltiin luotu kokonaan uusi tiedosto
        
        
        # Cancelling the new commit by deleting it, and setting device's commit to the old one
        begin
          cancelCommit(commit)
        rescue Exception => ex
          putsE(ex)
        end
        return false
      end
     
     # If parsing the files succeeded, returns true
    return true
  end
  
  
  
  
  
  
  
  
  
  def cancelCommit(commit)
  
    puts "Cancelling the new commit by deleting it, and setting device's commit to the old one, deleting also the blobs, blobs_in_commits and devfiles concenring about this commit"
          
    begin
      
      puts "Deleting blobs and blobs_in_commits.."
      BlobsInCommit.find(:all, :conditions => ["commit_id = ?", commit.id.to_s]).each do |b_in_c|
        b = Blob.find_by_id(b_in_c.blob_id)
        BlobsInCommit.delete_all(["commit_id = ? AND blob_id = ?", b_in_c.commit_id.to_s, b_in_c.blob_id.to_s])
        
        if not b
          puts "..ei ollu blobii"
        else
          puts "..blobi oli juu"
        end
                
        if b
          b.delete
        end
      end
    
      puts "done!"
      
      
      puts "Deleting the devfiles that are created in this commit!"
      @changed_files.each do |key, df|
        if not df[:dev_file_id]
          puts "  Deleting devfile: #{key}"
          new_df = Devfile.find_by_name_and_path_and_device_id(df['name'], df['path'], @device.id)
          new_df.delete if new_df
          puts "  done!"
        end
      end
      
      
      puts"done!"
      
      
      puts "Setting the old commit_id to devfile.."
      old_commit_id = @prev_commit != nil ? @prev_commit.id : nil
      @device.update_attribute(:commit_id, old_commit_id)
      
      
      puts "done!"
      
      commit_hash = commit.commit_hash
      
      puts "deleting the actual commit.."
      commit.delete
      
      puts "done!"
      
      
      puts "Cancelled the commit: " + commit_hash
    
      if @notify then XmppHelper::sendXmppMessage(@device.xmppname, "cancelled commit: " + commit_hash) end
    
    rescue Exception => exception
      puts "Error in cancelling the commit: #{exception.to_s}"
      puts "  -- line #{exception.backtrace[0].to_s}"
      commit.delete
    end


  end


  
  
  
  
  # add blobs from prev_commit to commit ignoring blobs in changed_files
  #
  # parameters: prev_commit - The previous commit
  #             commit - new commit
  #             changed_files - list of files to ignore
  #
  def addUnchangedFilesToCommit(prev_commit, commit, changed_files) #:doc:

    devfiles_of_prev_commit = Devfile.find_by_sql("select devfiles.path, devfiles.name, devfiles.blob_id from devfiles, blobs, blobs_in_commits where blobs.devfile_id=devfiles.id and blobs_in_commits.blob_id=blobs.id and blobs_in_commits.commit_id=#{prev_commit.id};")
    if devfiles_of_prev_commit.size > 0
      ActiveRecord::Base.connection.execute("begin")
      now = DateTime.now
      devfiles_of_prev_commit.each do |df|
        if not changed_files.has_key?(df.path + df.name)
          begin
            sql = "insert into blobs_in_commits(blob_id, commit_id, created_at, updated_at) values('#{df['blob_id']}', '#{commit.id}', '#{now}', '#{now}');"
            ActiveRecord::Base.connection.execute(sql)
          rescue
            # do nothing
          end
        end
      end
      ActiveRecord::Base.connection.execute("commit")
    end
  end
  
  
  
  
  
  
  
  
  
  #
  #   Checkse if devfile has any user added observers and sends notification to those nodes
  #
  def checkForObservers(devfile, username, devicename)
    begin
      path = "/user/" + username + "/device/" + devicename + "/files" + devfile.path + devfile.name
      devfile.file_observers.each do |fo|
        begin
          if fo
            XmppHelper::notificationToNode(fo, devfile, "Content updated!")
          end
        rescue Exception => ex
          putsE(ex)
        end    
      end      
    rescue Exception => e
      puts "Error in cheking checking devfile for observers!"
      puts "  -- line: #{e.backtrace[0].to_s}"
    end
  end
  
  
  
  
  
  
  
    # Updates file's metadata to db
  #
  # parameters: f - filehash
  #             commit - the commit the file belongs to
  #
  # @device has to be set.
  def updateDevfile(f, commit) #:doc:
    
    dev_file = nil
    
    begin
      # Checks if there is any changes in files.
      f_filedate = DateTime.strptime(f['filedate'], "%T %F")
      f_filedate = f_filedate.strftime('%F %T').to_s        
      
      now = DateTime.now.strftime('%F %T')
puts "name: #{f['name']}"
puts "path: #{f['path']}"
      puts "Finding devfile.."
      dev_file = @device.devfiles.find(:first, :conditions => ["name = ? and path = ?", f['name'], f['path']])
      if dev_file != nil
        puts "devfile found: " + dev_file.id.to_s
      else
        puts "Devfile #{f['path']}#{f['name']} not found"
        raise Exception.new("Devfile not found. Can not update it!")
      end
      
      
      blob = dev_file.blobs.find_by_blob_hash_and_devfile_id(f['blob_hash'], dev_file.id)
      if blob != nil
        puts "Blob already exists!"
        puts "Blob: " +  blob.id.to_s
        return
      else
        puts "Blob was not found!"
      end
      
      # Finds the blob that is newest one
      previous_blob_id = nil
      current_blob = dev_file.blobs.find_by_id(dev_file.blob_id)
      if current_blob != nil
        previous_blob_id = current_blob.id.to_s
        puts "Current blob: " +  current_blob.id.to_s
        
      end
      
      # If the blob, didn't exist yet, creates it. Ensures that blob will have version number.
      if blob == nil #or current_blob == nil
        version = 0
        if current_blob != nil
          version = current_blob.version + 1
        end
        
        if f['uploaded']
          
          puts "uploaded: true"
          ul = '1'
        else
          puts "uploaded: false"
          ul = '0'
        end
        
        puts "Creates new blob, verion num: " +  version.to_s
        sql = "insert into blobs(blob_hash, created_at, updated_at, size, filedate, uploaded, version, devfile_id, predecessor_id, latitude, longitude) values('#{f['blob_hash']}', '#{now}', '#{now}', '#{f['size']}', '#{f_filedate}', '#{ul}', '#{version}', '#{dev_file.id}', '#{previous_blob_id}', '#{@commit_location['latitude']}', '#{@commit_location['longitude']}');"
        ActiveRecord::Base.connection.execute(sql)
      end
      
      puts "Finding the newly created blob.."
      blob = dev_file.blobs.find_by_blob_hash(f['blob_hash'])
      puts " found blob: " + blob.id.to_s
      
      current_blob.update_attribute(:follower_id, blob.id)
      
      puts "Updating devfile"
      # Updates changes in devfile (current blob)
      sql = "update devfiles set filetype = '#{f['filetype']}', latitude = '#{f['latitude']}', longitude = '#{f['longitude']}', blob_id = '#{blob.id.to_s}', updated_at = '#{now}'  where name = '#{f['name']}' and path = '#{f['path']}' and device_id = #{@device.id};"
      puts " SQL: " + sql.background(:red)
      ActiveRecord::Base.connection.execute(sql)
      
      BlobsInCommit.find_or_create_by_blob_id_and_commit_id(blob.id, commit.id)
      
      
    rescue => e
      puts "Errors in updating file" + e
      raise e
    end
    
    puts "devfile updated!"
    return dev_file
  end



  # Creates metadata of a new file to db
  #
  # parameters: f - file
  #             commit - the commit the file belongs to
  #
  # @device has to be set.
  def createDevfile(f, commit) #:doc:
    
    dev_file = nil
    blob = nil
    b_in_c = nil
    
    # If file already exists, raises an error but nothing needs to be deleted (except the commit is cancelled)
    begin    
      dev_file = Devfile.find_by_name_and_path_and_device_id(f['name'], f['path'], @device.id)
      if dev_file != nil
        puts "Devfile: #{f['path'] + f['name']} already exits, cannot create, use update instead"
        #raise ArgumentError.new("Devfile already exits for this device, cannot use CREATE -method, use UPDATE instead to add new version")
        
        # This is tested! Not sure how well it works..
        puts "Devfile already found -> updates it!"
        #updateDevfile(f, commit)
      end
    rescue Exception => e
      puts e.to_s
      puts e.backtrace[0].to_s
      raise e
    end
puts "name: #{f['name']}"
puts "path: #{f['path']}"
    
    # If something goes wrong, raises an error, and deletes the data created
    begin
      
      puts "Creating new dev_file, blob etc.."
      
    
      f_filedate = DateTime.strptime(f['filedate'], "%T %F")
      f_filedate = f_filedate.strftime('%F %T').to_s
      
      now = DateTime.now
      
      # get or create devfile
      dev_file = Devfile.find_or_create_by_name_and_path_and_device_id(f['name'], f['path'], @device.id)
      if dev_file.created_at >= now
        sql = "update devfiles set filetype='#{f['filetype']}', path='#{f['path']}', privatefile=0 where id=#{dev_file.id}" 
        ActiveRecord::Base.connection.execute(sql)
      end
      
      # get or create blob
      blob = Blob.find_or_create_by_blob_hash_and_devfile_id(f['blob_hash'], dev_file.id)
      if blob.created_at >= now # if just created
        # Version number
        version = 0
        predecessor_blob_id = "NULL"
        follower_blob_id = "NULL"
        if dev_file.blob_id != nil
          predecessor_blob_id = dev_file.blobs.find_by_id(dev_file.blob_id) ? dev_file.blobs.find_by_follower_id(dev_file.blob_id).id.to_s : "NULL"
          follower_blob_id = dev_file.blobs.find_by_predecessor_id(blob.id) ? dev_file.blobs.find_by_predecessor_id(blob.id).id.to_s : "NULL"
          version = dev_file.blobs.find_by_id(dev_file.blob_id).version + 1 
        end
        
puts "predecessor_id=#{predecessor_blob_id.to_s},"
puts "follower_id=#{follower_blob_id.to_s},"
puts "size=#{f['size'].to_s}," 
puts "filedate='#{f_filedate.to_s}'," 
puts "version=#{version.to_s}," 
puts "uploaded=#{f['uploaded'].to_s},"  
puts "latitude=#{@commit_location['latitude'].to_s}, " 
puts "longitude=#{@commit_location['longitude'].to_s} "        
        
        if f['uploaded']
          puts "uploaded: true"
          ul = '1'
        else
          puts "uploaded: false"
          ul = '0'
        end
        
        sql = "update blobs set uploaded=#{ul}, predecessor_id=#{predecessor_blob_id.to_s}, follower_id=#{follower_blob_id.to_s}, size=#{f['size'].to_s}, filedate='#{f_filedate.to_s}', version=#{version.to_s}, latitude=#{@commit_location['latitude'].to_s}, longitude=#{@commit_location['longitude'].to_s} where id=#{blob.id};"
puts "sql: " + sql
        
        ActiveRecord::Base.connection.execute(sql)
      end
      
      # Creates association between blob and commit
      b_in_c = BlobsInCommit.find_or_create_by_blob_id_and_commit_id(blob.id, commit.id)
      
      # update blob_id to devfile
      if dev_file.blob_id != blob.id
        sql = "update devfiles set blob_id=#{blob.id} where id=#{dev_file.id};"
        ActiveRecord::Base.connection.execute(sql)
      end
      
      
      #checkForObservers(dev_file)
      
      # If parent_blob_hash is given, tries to find the parent, and creates new branch from the parent
      if f['file_origin']        
        createBranch(f['file_origin'], blob)
      end

    rescue Exception => e
      puts "        -- Error in createDevfile: " + e
      puts "          -- line: #{e.backtrace[0].to_s}"
      
      puts "Deleting created data.."
      
      # If dev_file was created now, deletes it
      dev_file.delete if dev_file
      puts "Deleted created dev_file!" if dev_file
      
      if blob      
        if b_in_c
          BlobsInCommit.delete_all(["commit_id = ? AND blob_id = ?", b_in_c.commit_id.to_s, blob.blob_id.to_s])
          puts "Deleted created blobs_in_commits!" if b_in_c
        end
        blob.delete 
        puts "Deleted created blob!"
      end
      
      # Throws forward the exception..
      raise e
    end
    puts "File created"
    return dev_file
  end
  
  
  
  
  
  
  
  
  
  
  
  
  def checkForThumbs(commit) #:doc:
    prev_commit_blob_ids = Array.new
    prev_commit = Commit.find(:first, :conditions => ["id = ?", commit.previous_commit_id])
    if prev_commit
      prev_commit.blobs.find_each(:batch_size => 1500) do |pb|
        prev_commit_blob_ids.push(pb.id)
      end
    end
    
    blobs_without_thumb = Array.new
    new_thumbs = 0
    new_thumbs_without_thumb = 0
    prev_thumbs_ok = true
    commit.blobs.find_each(:batch_size => 1500) do |blob|
      if blob.thumbnail_name == nil and not prev_commit_blob_ids.include?(blob.id) and not blobs_without_thumb.include?(blob.blob_hash)
        blobs_without_thumb.push(blob.blob_hash)
        new_thumbs_without_thumb += 1
        new_thumbs += 1
      elsif blob.thumbnail_name == nil and not blobs_without_thumb.include?(blob.blob_hash)
        blobs_without_thumb.push(blob.blob_hash)
        prev_thumbs_ok = false
      elsif blob.thumbnail_name != nil and not prev_commit_blob_ids.include?(blob.id)
        new_thumbs += 1
      end
    end
    
    if blobs_without_thumb.size == 0 # we have all thumbs, do nothing
      return
    elsif prev_thumbs_ok and new_thumbs_without_thumb == new_thumbs # all new thumbs missing
      if @notify then XmppHelper::sendXmppMessage(@device.xmppname, "thumbs " + commit.commit_hash) end
    else
      # some thumbs are missing. get them.
      i = 0
      blobs_per_message = 100
      message = blobs_without_thumb[i...blobs_per_message]
      while message != nil do
        if @notify then XmppHelper::sendXmppMessage(@device.xmppname, "thumbs " + commit.commit_hash + " " + message.join(" ")) end
        i += blobs_per_message
        message = blobs_without_thumb[i...blobs_per_message]
      end
    end  
  end
  
  
  
  
  
  
  
  
  
    def putsE(e)
        puts "Error: #{e.to_s}"
        puts "  -- line: #{e.backtrace[0].to_s}"
    end
  
  
  
  
  
  
end